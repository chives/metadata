# FSi Metadata Component Documentation

FSi Metadata Component is a library that provide some commonly used mechanisms to 
read configurations for classes from different sources like annotations, yaml or xml.
At the moment only php files annotations are supported.

## Setup and autoloading ##

We highly recommend to use autoloader generated by composer.phar

**Adding reflection into composer.json**

    {
        ... 
        "require": {
            ... 
            "fsi/metadata": "0.9.*" 
            ...
        },
        ...
    }

## Usage ##

FSi Metadata Component provides ClassMetadata object that can be easly overwritten. Default ClassMetadata object allows 
you to strore inside of it configuration for class, properties and methods. 
This can be done by using methods "addClassMetadata", "addPropertyMetadata", "addMethodMetadata". 

What you need to do is to create class that extends from one of abstract drivers like AbstractAnnotationDriver. 

Example of reading annotations from php class files. 


**Annotation driver** 

    namespace FSi\Bundle\SiteBundle\Metadata\Driver;
    
    use FSi\Component\Metadata\ClassMetadataInterface;
    use FSi\Component\Metadata\Driver\AbstractAnnotationDriver;
    
    class AnnotationDriver extends AbstractAnnotationDriver
    {
        public function loadClassMetadata(ClassMetadataInterface $metadata)
        {
            $classReflection  = $metadata->getClassReflection();
            $className        = $classReflection->getName();

            $classReflectionProperties = $classReflection->getProperties();
            foreach ($classReflectionProperties as $property) {
                if ($property->getDeclaringClass()->getName() == $className) {
                    foreach ($this->reader->getPropertyAnnotations($property) as $element) {
                        $metadata->addPropertyMetadata($property->name, $element->name, $element->value);
                    }
                }
            }
        }
    }
    
**Annotation declaration**

    namespace FSi\Bundle\SiteBundle\Metadata\Mapping\Annotation;
    
    use Doctrine\Common\Annotations\Annotation;
    
    /** @Annotation */
    final class Field extends Annotation {
        public $name;
        public $value;
    }

**Example action in symfony 2 controller**

    public function metadataAction()
    {
        $cache  = new ArrayCache();//ApcCache();

        $driver = new DriverChain(array(
            new \FSi\Bundle\SiteBundle\Metadata\Driver\AnnotationDriver($this->get('annotation_reader'))
        ));
        
        $factory = new MetadataFactory($driver, $cache);
        
        $metdata = $factory->getClassMetadata('FSi\Bundle\SiteBundle\Entity\MetaTest');
    }

Sometimes default ClassMetadata is not enough. You can create own class that implements 
ClassMetadataInterface and pass class name into MetadataFactory constructor as third parameter. 

**Factory constructor example**

    $factory = new MetadataFactory($driver, $cache, 'FSi\SiteBundle\Metadata\MyClassMetadata');

If you want to use Metadata Component in two separate mechanisms, inside of the 
same application you should create new MetatadaFactory and MetadataDriver in each 
mechanism but cache driver may be the same object each time. It is possible because 
cache mechanism is used with different namespace for each factory object.  
